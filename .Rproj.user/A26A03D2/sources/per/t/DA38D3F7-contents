\name{sKPCA}
\alias{sKPCA}
\title{sketched Kernel PCA}
\description{
   Approximate Kernel PCA with Randomized Sketches.
}
\usage{
  sKPCA(trdata, tsdata=NULL,d, m=ceiling(sqrt(nrow(trdata))), Stype='ROS',  kern=rbfdot(sigma=0.5), seed=2, fast_version=0)

}
\arguments{
  \item{trdata}{a n*p matrix,  the train data for KPCA.}
  \item{tsdata}{a n1*p matrix, the test data used for reconstrction error.}
  \item{d}{a positve integer, the number of principal component to be extracted.}
  \item{m}{the projection dimension}
  \item{Stype}{a character, the sketch type, include
    'subGaussian', 'ROS' and 'subSampling', default as ROS.}
  \item{kern}{a kernel function generated by \link{kernlab} package, default as gaussian kernel.}
  \item{seed}{a non-negative integer, specify the random seed for generating random matrix, default as 2.}
  \item{fast_version}{a logical value. Here we provide two approximate way based on random sketch matrix, one faster but lower precision, other a little slower but higher precision, both much faster than original KPCA.}
  \item{center}{a logical value, specify sketched KPCA for original Gram matrix or centralized Gram matrix, defualt as True.}
}
\details{
  This function is used to compute the principal component scores. If center=True, it
  perform sketched KPCA for centralized Gram matrix, otherwise for original Gram matrix.
}
\value{
  return a list with class name 'sKPCA' and including following components,
  \item{alpha}{a n*d matrix, the first d principal component vectors in each column.}
  \item{alpha_rotate}{a n*d matrix, the first d  rotated principal component vectors in each column.}
  \item{prop_var}{a scalar, the proportion of exaplained variance.}
}
\references{
  nothing.
}
\author{
  Liu Wei
}
\note{
  nothing
}
\seealso{
  nothing
}
\examples{
  library(kernlab)
  data(iris)
  test <- sample(1:150,20)
  # original KPCA from kernlab package
  kpc <- kpca(~.,data=iris[-test,-5],kernel="rbfdot",
              kpar=list(sigma=0.2),features=2)
  #print the principal component vectors
  feat <- kpc@rotated
  # Sketched Kernel PCA
  library(sKPCA)
  d <- 2
  kern <- rbfdot(sigma = 0.2)
  fkpca <- sKPCA(iris[-test,-5], d=d, seed = 8, kern=kern)
  alpha_rotate <- fkpca$alpha_rotate

  fkpca1 <- sKPCA(iris[-test,-5], d=d, seed = 8, kern=kern, fast_version = T)
  alpha_rotate1 <- fkpca1$alpha_rotate
  # original KPCA from sKPCA package
  okpca <- oKPCA(iris[-test,-5], d=d, kern=kern)
  alpha_orotate <- okpca$alpha_rotate

  # plot the principal component for diffrent methods
  par(mfrow=c(2,2))
  plot(feat,col=as.integer(iris[-test,5]),
       xlab="1st Principal Component",ylab="2nd Principal Component", main='KPCA')
  plot(alpha_orotate[,1:2],col=as.integer(iris[-test,5]),
       xlab="1st Principal Component",ylab="2nd Principal Component", main='oKPCA')

  plot(alpha_rotate[,1:2],col=as.integer(iris[-test,5]),
       xlab="1st Principal Component",ylab="2nd Principal Component", main='sKPCA1')
  plot(alpha_rotate1[,1:2],col=as.integer(iris[-test,5]),
       xlab="1st Principal Component",ylab="2nd Principal Component", main='sKPCA2')

  ## Example 2. Big data
  n <- 2000
  X <- matrix(rnorm(n*50), n, 50)
  d <- 2
  kern <- rbfdot(sigma = 0.2)
  system.time(
  fkpca <- sKPCA(X, d=d, seed = 8, kern=kern)
  )
  system.time(
    fkpca1 <- sKPCA(X, d=d, seed = 8, kern=kern, fast_version = T)
  )
  system.time(
    okpca <- oKPCA(X, d=d, kern=kern)
  )

  system.time(
    kpc <- kpca(X,kernel="rbfdot",
                kpar=list(sigma=0.2),features=2)
)
}
\keyword{sketch matrix}
